/*!
# Research to Documentation Workflow Demo

This example demonstrates the complete Phase 2 Task 2.0 implementation:
Research to Documentation workflow with cross-system integration.

## Features Demonstrated

1. **Declarative Workflow Definition**: YAML-based workflow schema
2. **Cross-System Integration**: AI Tutor ‚Üî Workflow System communication
3. **NotionClientNode**: Enhanced documentation page creation
4. **Workflow API**: HTTP endpoints for triggering and monitoring
5. **Template Engine**: Dynamic content rendering
6. **Error Handling**: Comprehensive error recovery

## Usage

```bash
# Terminal 1: Start AI Tutor Service (if available)
cd examples/python_client
python ai_tutor_service.py

# Terminal 2: Run this demo
cargo run --example research_to_docs_workflow_demo
```

## Architecture

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Workflow      ‚îÇ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ   Registry   ‚îÇ‚óÄ‚îÄ‚îÄ‚îÄ‚îÇ   AI Tutor      ‚îÇ
‚îÇ   API Server    ‚îÇ    ‚îÇ   Service    ‚îÇ    ‚îÇ   Service       ‚îÇ
‚îÇ   (Port 8081)   ‚îÇ    ‚îÇ              ‚îÇ    ‚îÇ   (Python)      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ                                           ‚ñ≤
         ‚îÇ                                           ‚îÇ
         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂ HTTP/MCP Cross-System ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                         Communication
         ‚îÇ
         ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Notion MCP    ‚îÇ
‚îÇ   Server        ‚îÇ
‚îÇ   (Port 3001)   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```
*/

use actix_web::web;
use serde_json::json;
use std::time::Duration;
use tokio::time::sleep;

use backend::api::workflows::{WorkflowService, TriggerWorkflowRequest};

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    env_logger::init();
    
    println!("üéØ Research to Documentation Workflow Demo");
    println!("==========================================");
    println!("üìã Complete Phase 2 Task 2.0 demonstration");
    
    // Create workflow service
    let workflow_service = match WorkflowService::new().await {
        Ok(service) => {
            println!("‚úÖ Workflow service initialized successfully");
            service
        }
        Err(e) => {
            println!("‚ùå Failed to initialize workflow service: {}", e);
            return Err(e.into());
        }
    };
    
    // List available workflows
    println!("\nüìã Available Workflows:");
    let workflows = workflow_service.list_workflows().await;
    for workflow in &workflows {
        println!("   ‚Ä¢ {}", workflow);
    }
    
    // Create workflow service data
    let service_data = web::Data::new(workflow_service);
    
    println!("\nüöÄ Starting Demo (Server would run on http://localhost:8081)");
    
    // Demonstrate workflow trigger via API
    println!("\nüé¨ Demonstrating Research to Documentation Workflow");
    println!("==================================================");
    
    // Example 1: Basic research workflow
    println!("\nüìö Example 1: Basic Machine Learning Research");
    let trigger_request = TriggerWorkflowRequest {
        workflow_name: "research_to_documentation".to_string(),
        inputs: json!({
            "topic": "machine learning fundamentals",
            "difficulty": "intermediate",
            "max_sources": 8
        }),
        config: None,
    };
    
    match service_data.trigger_workflow(trigger_request).await {
        Ok(response) => {
            println!("‚úÖ Workflow triggered successfully!");
            println!("   Instance ID: {}", response.instance_id);
            println!("   Status URL: {}", response.status_url);
            println!("   Initial Status: {:?}", response.status);
            
            // Monitor workflow progress
            demo_workflow_monitoring(&service_data, response.instance_id).await;
        }
        Err(e) => {
            println!("‚ùå Failed to trigger workflow: {}", e);
        }
    }
    
    // Example 2: Advanced research with configuration overrides
    println!("\nüß† Example 2: Advanced AI Research with Custom Config");
    let advanced_trigger_request = TriggerWorkflowRequest {
        workflow_name: "research_to_documentation".to_string(),
        inputs: json!({
            "topic": "transformer neural networks and attention mechanisms",
            "difficulty": "advanced",
            "max_sources": 15
        }),
        config: Some(backend::api::workflows::WorkflowConfigOverrides {
            timeout: Some(900), // 15 minutes
            retries: Some(3),
            continue_on_error: Some(false),
            environment: Some([
                ("NOTION_RESEARCH_FOLDER".to_string(), "ai-research-advanced".to_string()),
            ].iter().cloned().collect()),
        }),
    };
    
    match service_data.trigger_workflow(advanced_trigger_request).await {
        Ok(response) => {
            println!("‚úÖ Advanced workflow triggered successfully!");
            println!("   Instance ID: {}", response.instance_id);
            println!("   Configuration: Custom timeout, enhanced retries");
            
            // Monitor this workflow too
            demo_workflow_monitoring(&service_data, response.instance_id).await;
        }
        Err(e) => {
            println!("‚ùå Failed to trigger advanced workflow: {}", e);
        }
    }
    
    // Example 3: Research to Slack workflow
    println!("\nüì± Example 3: Research to Slack Summary");
    let slack_trigger_request = TriggerWorkflowRequest {
        workflow_name: "research_to_slack".to_string(),
        inputs: json!({
            "topic": "rust programming language best practices",
            "channel": "#engineering-updates"
        }),
        config: None,
    };
    
    match service_data.trigger_workflow(slack_trigger_request).await {
        Ok(response) => {
            println!("‚úÖ Slack workflow triggered successfully!");
            println!("   Instance ID: {}", response.instance_id);
            
            demo_workflow_monitoring(&service_data, response.instance_id).await;
        }
        Err(e) => {
            println!("‚ùå Failed to trigger Slack workflow: {}", e);
        }
    }
    
    // List all running instances
    println!("\nüìä All Workflow Instances Summary");
    println!("=================================");
    let instances = service_data.list_instances().await;
    for (instance_id, status, workflow_name) in instances {
        println!("   {} | {:?} | {}", instance_id, status, workflow_name);
    }
    
    // Show system architecture summary
    print_architecture_summary();
    
    println!("\n‚ú® Demo completed! Would run server on http://localhost:8081");
    println!("üí° Available API endpoints:");
    println!("   GET  /api/v1/workflows/available");
    println!("   GET  /api/v1/workflows/instances");
    println!("   POST /api/v1/workflows/trigger");
    println!("   GET  /api/v1/workflows/status/{{instance_id}}");
    
    Ok(())
}

async fn demo_workflow_monitoring(
    service: &web::Data<WorkflowService>,
    instance_id: uuid::Uuid,
) {
    println!("   üîç Monitoring workflow progress...");
    
    let mut attempts = 0;
    let max_attempts = 10;
    
    while attempts < max_attempts {
        sleep(Duration::from_millis(1000)).await;
        
        match service.get_workflow_status(instance_id).await {
            Ok(status) => {
                println!("   üìä Progress: {}% ({}/{} steps completed)", 
                    status.progress.percentage,
                    status.progress.completed_steps,
                    status.progress.total_steps
                );
                
                match status.status {
                    backend::workflows::schema::WorkflowStatus::Completed => {
                        println!("   ‚úÖ Workflow completed successfully!");
                        if let Some(outputs) = &status.outputs {
                            if let Some(notion_url) = outputs.get("notion_page_url") {
                                println!("   üìÑ Documentation: {}", notion_url);
                            }
                            if let Some(summary) = outputs.get("research_summary") {
                                let preview = summary.as_str()
                                    .map(|s| if s.len() > 100 { format!("{}...", &s[..100]) } else { s.to_string() })
                                    .unwrap_or_else(|| "No summary".to_string());
                                println!("   üìù Summary: {}", preview);
                            }
                        }
                        break;
                    }
                    backend::workflows::schema::WorkflowStatus::Failed => {
                        println!("   ‚ùå Workflow failed!");
                        if let Some(error) = &status.error {
                            println!("   üí• Error: {}", error.message);
                        }
                        break;
                    }
                    backend::workflows::schema::WorkflowStatus::Running => {
                        // Show currently running steps
                        for (step_id, step_info) in &status.steps {
                            if step_info.status == backend::workflows::schema::StepStatus::Running {
                                println!("   ‚ö° Running: {}", step_id);
                            }
                        }
                    }
                    _ => {}
                }
            }
            Err(e) => {
                println!("   ‚ö†Ô∏è  Failed to get status: {}", e);
                break;
            }
        }
        
        attempts += 1;
    }
    
    if attempts >= max_attempts {
        println!("   ‚è∞ Monitoring timeout reached");
    }
}


fn print_architecture_summary() {
    println!("\nüèóÔ∏è  System Architecture Summary");
    println!("==============================");
    
    println!("\n‚úÖ Completed Phase 2 Components:");
    println!("   üìã Task 2.1: ‚úÖ YAML workflow schema definitions");
    println!("   üîó Task 2.2: ‚úÖ Cross-system step type for AI Tutor integration");
    println!("   üìÑ Task 2.3: ‚úÖ NotionClientNode for documentation creation");
    println!("   üîß Task 2.4: ‚úÖ Workflow parser with validation and cycle detection");
    println!("   üöÄ Task 2.5: ‚úÖ Workflow trigger API endpoint (POST /api/v1/workflows/trigger)");
    println!("   üìä Task 2.6: ‚úÖ Workflow status API endpoint (GET /api/v1/workflows/status/{{id}})");
    
    println!("\nüéØ Integration Points:");
    println!("   ‚Ä¢ Declarative YAML workflow definitions");
    println!("   ‚Ä¢ Cross-system communication via HTTP/MCP");
    println!("   ‚Ä¢ Template-driven content generation");
    println!("   ‚Ä¢ RESTful API for workflow management");
    println!("   ‚Ä¢ Real-time status monitoring");
    println!("   ‚Ä¢ Comprehensive error handling");
    
    println!("\nüìä Built-in Workflow Templates:");
    println!("   ‚Ä¢ research_to_documentation: AI research ‚Üí Notion pages");
    println!("   ‚Ä¢ research_to_slack: AI research ‚Üí Slack summaries");
    
    println!("\nüîÑ Execution Flow:");
    println!("   1. Client triggers workflow via HTTP API");
    println!("   2. Workflow parser validates and creates instance");
    println!("   3. Executor runs cross-system and node steps");
    println!("   4. Template engine renders dynamic content");
    println!("   5. Results stored and available via status API");
    
    println!("\nüéä Phase 2 Task 2.0 - COMPLETE!");
    println!("   Research to Documentation workflow system is fully operational!");
}